<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini-jeu Radiologie ‚Äî 3D</title>
<style>
  :root{
    --bg:#0f1724; --accent:#6ee7b7; --muted:#94a3b8;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071126 0%, #07172a 100%);color:#e6eef8}
  .app{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:24px}
  .container{width:100%;max-width:1200px;border-radius:12px;overflow:hidden;display:grid;grid-template-columns:260px 1fr 360px;box-shadow:0 12px 40px rgba(0,0,0,.6);background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01))}
  .left{padding:20px;border-right:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column;gap:12px}
  .left h2{margin:0;color:var(--accent)}
  .btn{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);padding:12px;border-radius:10px;color:var(--accent);font-weight:700;cursor:pointer;transition:transform .12s}
  .btn:hover{transform:translateY(-4px)}
  .center{position:relative;padding:8px;display:flex;align-items:center;justify-content:center}
  .scene-wrap{width:680px;height:480px;border-radius:10px;overflow:hidden;background:linear-gradient(180deg,#071c2b,#041220);box-shadow:inset 0 6px 40px rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center}
  canvas{display:block;width:100%;height:100%}
  .right{padding:20px;border-left:1px solid rgba(255,255,255,0.03)}
  .right h3{margin:0;color:var(--accent)}
  .info{margin-top:12px;background:rgba(255,255,255,0.02);padding:12px;border-radius:8px;min-height:160px;color:#dbeafe}
  .overlay{position:fixed;inset:0;display:grid;place-items:center;background:linear-gradient(180deg, rgba(2,6,23,0.7), rgba(2,6,23,0.85));z-index:40}
  .modal{background:linear-gradient(180deg,#071226,#061126);padding:24px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);text-align:center;color:var(--muted)}
  .primary{background:linear-gradient(90deg,var(--accent),#9be6d1);border:none;padding:10px 14px;border-radius:10px;color:#052018;font-weight:800;cursor:pointer}
  .small{font-size:13px;color:var(--muted);margin-top:8px}
  @media (max-width:980px){ .container{grid-template-columns:1fr;grid-template-rows:auto auto auto}.scene-wrap{width:92vw;height:56vw} }
</style>
</head>
<body>
<div class="app">
  <div class="container" id="appUI" aria-hidden="true">
    <div class="left">
      <h2>Actions</h2>
      <button class="btn" id="btnCur">1. Appliquer une m√©thode curative</button>
      <button class="btn" id="btnPrev">2. Appliquer une m√©thode pr√©ventive</button>
      <button class="btn" id="btnIRM">3. Faire un IRM</button>
      <div style="flex:1"></div>
      <div class="small">Observe la sc√®ne 3D : l'IRM fera entrer le patient dans le tube. Les m√©decins arrivent vus du dessus.</div>
    </div>

    <div class="center">
      <div class="scene-wrap" id="canvasContainer" role="main" aria-label="Sc√®ne 3D d'op√©ration">
        <!-- Le canvas WebGL sera inject√© ici -->
      </div>
    </div>

    <div class="right">
      <h3>Informations</h3>
      <div class="info" id="info">
        <p>Vous √™tes m√©decin. Choisissez une m√©thode pour soigner le patient. Animations 3D en direct.</p>
      </div>
    </div>
  </div>
</div>

<!-- Intro -->
<div class="overlay" id="intro">
  <div class="modal">
    <h2 style="color:var(--accent);margin:0 0 8px 0">Bienvenue</h2>
    <p class="small">Vous √™tes m√©decin. √âtudiez la radiologie pour soigner le patient. Appuyez sur <strong>Commencer</strong> pour acc√©der au mini-jeu 3D.</p>
    <div style="margin-top:14px;display:flex;gap:10px;justify-content:center">
      <button class="primary" id="startBtn">Commencer</button>
    </div>
  </div>
</div>

<!-- Finish -->
<div class="overlay" id="finish" style="display:none;">
  <div class="modal">
    <h2 style="color:var(--accent);margin:0 0 8px 0">Patient sauv√© ! üéâ</h2>
    <p class="small">Bravo ‚Äî vous avez test√© les 3 m√©thodes.</p>
    <div style="margin-top:12px"><button class="primary" id="restartBtn">Recommencer</button></div>
  </div>
</div>

<!-- Three.js via modules -->
<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
  import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';
  // small shader pass for subtle vignette (no external lib)

  // UI elements
  const btnCur = document.getElementById('btnCur');
  const btnPrev = document.getElementById('btnPrev');
  const btnIRM = document.getElementById('btnIRM');
  const infoPanel = document.getElementById('info');
  const container = document.getElementById('canvasContainer');
  const intro = document.getElementById('intro');
  const finish = document.getElementById('finish');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const appUI = document.getElementById('appUI');

  const explanations = {
    curative: `<h4 style="color:var(--accent);margin:0">M√©thode curative</h4>
               <p style="margin:6px 0 0">Intervention guid√©e par l'imagerie : le m√©decin intervient directement sur la l√©sion (ex: radiologie interventionnelle).</p>`,
    preventive: `<h4 style="color:var(--accent);margin:0">M√©thode pr√©ventive</h4>
                 <p style="margin:6px 0 0">Actions pour r√©duire le risque et surveiller le patient (d√©pistage, surveillance).</p>`,
    irm: `<h4 style="color:var(--accent);margin:0">IRM</h4>
          <p style="margin:6px 0 0">Imagerie non invasive : l'IRM permet de diagnostiquer pr√©cis√©ment. Ici, le patient entre dans le tunnel.</p>`
  };

  // --- Three.js scene setup ---
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x061226, 0.02);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  container.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 200);
  camera.position.set(0, 5, 10);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.minDistance = 4;
  controls.maxDistance = 18;
  controls.maxPolarAngle = Math.PI / 2.1;

  // Lights
  const hemi = new THREE.HemisphereLight(0xb7eaf0, 0x081020, 0.45);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff, 0.9);
  dir.position.set(5, 8, 5);
  dir.castShadow = true;
  dir.shadow.mapSize.set(2048,2048);
  dir.shadow.camera.left = -10; dir.shadow.camera.right = 10; dir.shadow.camera.top = 10; dir.shadow.camera.bottom = -10;
  scene.add(dir);

  // subtle rim light
  const rim = new THREE.PointLight(0x6ee7b7, 0.3, 20);
  rim.position.set(-6, 4, -4);
  scene.add(rim);

  // ground / table
  const tableGeo = new THREE.PlaneGeometry(40, 40);
  const tableMat = new THREE.MeshStandardMaterial({ color: 0x071822, roughness: 0.9, metalness: 0.05 });
  const table = new THREE.Mesh(tableGeo, tableMat);
  table.rotation.x = -Math.PI / 2;
  table.position.y = -1.4;
  table.receiveShadow = true;
  scene.add(table);

  // --- Patient model (stylized capsule) ---
  const patientGroup = new THREE.Group();
  patientGroup.position.set(0, 0, 0);
  scene.add(patientGroup);

  // head
  const headMat = new THREE.MeshStandardMaterial({ color: 0xffe0c8, roughness: 0.6 });
  const headGeo = new THREE.SphereGeometry(0.6, 32, 32);
  const head = new THREE.Mesh(headGeo, headMat);
  head.castShadow = true;
  head.position.set(0, 1.1, 0);
  patientGroup.add(head);

  // body (rounded capsule)
  const bodyMat = new THREE.MeshStandardMaterial({ color: 0xffdfb8, roughness: 0.7 });
  const bodyTop = new THREE.SphereGeometry(0.9, 32, 32);
  const bodyBot = new THREE.SphereGeometry(0.9, 32, 32);
  const mid = new THREE.CylinderGeometry(0.9, 0.9, 1.8, 32);
  const topMesh = new THREE.Mesh(bodyTop, bodyMat);
  const botMesh = new THREE.Mesh(bodyBot, bodyMat);
  const midMesh = new THREE.Mesh(mid, bodyMat);
  topMesh.position.set(0, 0.2, 0);
  midMesh.position.set(0, -0.6, 0);
  botMesh.position.set(0, -1.6, 0);
  topMesh.castShadow = midMesh.castShadow = botMesh.castShadow = true;
  patientGroup.add(topMesh, midMesh, botMesh);

  // small label on body
  const labelGeo = new THREE.PlaneGeometry(1.1, 0.4);
  const labelMat = new THREE.MeshBasicMaterial({ color: 0x07232b });
  const label = new THREE.Mesh(labelGeo, labelMat);
  label.position.set(0, -0.4, 0.95);
  patientGroup.add(label);

  // center patient slightly above table
  patientGroup.position.y = -0.4;

  // --- MRI tube (realistic torus-like opening + inner cylinder) ---
  const tubeGroup = new THREE.Group();
  tubeGroup.position.set(0, -0.4, 0);
  scene.add(tubeGroup);

  // outer ring (rounded)
  const ringOuterMat = new THREE.MeshStandardMaterial({ color: 0xdffbf2, emissive: 0x083236, emissiveIntensity: 0.06, roughness: 0.35 });
  const ringGeo = new THREE.TorusGeometry(2.1, 0.45, 24, 80);
  const ring = new THREE.Mesh(ringGeo, ringOuterMat);
  ring.rotation.x = Math.PI / 2;
  ring.castShadow = true;
  ring.receiveShadow = false;
  tubeGroup.add(ring);

  // inner tunnel (slightly darker)
  const tunnelMat = new THREE.MeshStandardMaterial({ color: 0x0a2a2e, roughness: 0.6, metalness: 0.2 });
  const tunnelGeo = new THREE.CylinderGeometry(1.0, 1.0, 4.0, 64, 1, true);
  const tunnel = new THREE.Mesh(tunnelGeo, tunnelMat);
  tunnel.position.set(0, 0, -1.0);
  tunnel.rotation.x = 0;
  tunnel.receiveShadow = true;
  tubeGroup.add(tunnel);

  // animated inner glow ring (emissive slice)
  const glowMat = new THREE.MeshBasicMaterial({ color: 0x6ee7b7, transparent: true, opacity: 0.12 });
  const glowGeo = new THREE.RingGeometry(1.05, 1.9, 64);
  const glow = new THREE.Mesh(glowGeo, glowMat);
  glow.rotation.x = -Math.PI / 2;
  tubeGroup.add(glow);

  // hide tube initially (we will animate scale)
  tubeGroup.scale.set(0.001, 0.001, 0.001);
  tubeGroup.visible = false;

  // doctors: top-view stylized shapes
  const doctors = [];
  const docMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6, metalness: 0.05 });
  const docHeadMat = new THREE.MeshStandardMaterial({ color: 0xffe0c8 });

  const docPositions = [
    new THREE.Vector3(-2.6, -0.4, -0.4),
    new THREE.Vector3(2.6, -0.4, -0.4),
    new THREE.Vector3(-1.8, -0.4, 2.0),
    new THREE.Vector3(1.8, -0.4, 2.0)
  ];

  docPositions.forEach((pos, idx) => {
    const g = new THREE.Group();
    // body (flat rectangle) ‚Äî viewed from top, so flatten
    const body = new THREE.BoxGeometry(0.7, 0.15, 1.4);
    const bodyMesh = new THREE.Mesh(body, docMat);
    bodyMesh.position.set(0, 0, 0);
    bodyMesh.castShadow = true;
    // small head sphere
    const headS = new THREE.SphereGeometry(0.18, 12, 12);
    const headMesh = new THREE.Mesh(headS, docHeadMat);
    headMesh.position.set(0, 0.3, -0.45);

    g.add(bodyMesh, headMesh);
    g.position.copy(pos);
    g.scale.set(0.001, 0.001, 0.001); // start hidden
    g.userData = { idx };
    scene.add(g);
    doctors.push(g);
  });

  // subtle camera initial framing animation
  let clock = new THREE.Clock();

  // state flags
  const used = new Set();

  // FUNCTIONS: animations using simple tween approach (no external lib)
  function tween(props){
    // props: {object, to: {k:v}, duration(ms), easing, onComplete, onUpdate}
    const start = performance.now();
    const from = {};
    for(const k in props.to) from[k] = props.object[k] !== undefined ? props.object[k] : props.object.position[k];
    const duration = props.duration || 800;
    const ease = props.easing || (t => (--t)*t*t+1); // simple ease-out-cubic
    function frame(now){
      const t = Math.min(1, (now - start) / duration);
      const e = ease(t);
      for(const k in props.to){
        const s = from[k];
        const d = props.to[k];
        if(k in props.object) props.object[k] = s + (d - s) * e;
        else props.object.position[k] = s + (d - s) * e;
      }
      if(props.onUpdate) props.onUpdate(e);
      if(t < 1) requestAnimationFrame(frame);
      else if(props.onComplete) props.onComplete();
    }
    requestAnimationFrame(frame);
  }

  // helper show/hide tube with scaling + rotation to simulate 3D opening
  function showTube(open = true, callback){
    tubeGroup.visible = true;
    if(open){
      // scale up with slight rotation
      tubeGroup.scale.set(0.001,0.001,0.001);
      tween({ object: tubeGroup.scale, to: { x:1, y:1, z:1 }, duration: 700, onComplete: callback });
      // light pulse on glow
      let flash = {o:0.06};
      tween({ object: glow.material, to: { opacity: 0.18 }, duration: 450, onComplete: ()=>{ tween({ object: glow.material, to: { opacity:0.08 }, duration:600 }) }});
    } else {
      // scale down and hide
      tween({ object: tubeGroup.scale, to: { x:0.001, y:0.001, z:0.001 }, duration: 500, onComplete: ()=>{ tubeGroup.visible = false; if(callback) callback(); }});
    }
  }

  // IRM animation: open tube, slide patient in, then close + hide tube
  function playIRM(){
    // show tube
    showTube(true, ()=>{
      // slide patient forward (into negative z inside tunnel)
      tween({ object: patientGroup.position, to: { x:0, y:-0.4, z:-1.4 }, duration: 950, onComplete: ()=>{
        // brief scan "hold"
        setTimeout(()=>{
          // retract patient
          tween({ object: patientGroup.position, to: { x:0, y:-0.4, z:0 }, duration: 800 });
          // close tube
          setTimeout(()=> showTube(false, ()=>{}), 160);
        }, 400);
      }});
      // slight scale / opacity to imply depth
      tween({ object: patientGroup.scale, to: { x:0.86, y:0.86, z:0.86 }, duration: 900, onComplete: ()=>{ tween({ object: patientGroup.scale, to: { x:1, y:1, z:1 }, duration:700 }) }});
    });

    // glow pulse inside tunnel timed
    tween({ object: glow.material, to: { opacity: 0.28 }, duration: 300, onComplete: ()=>{ tween({ object: glow.material, to: { opacity: 0.08 }, duration: 900 }); }});
  }

  // Doctors animation: appear (scale up), move slightly toward patient, stay, then leave (scale down)
  function playDoctors(){
    const inTime = 450, hold = 700, outTime = 500;
    doctors.forEach((d, i) => {
      // appear with delay
      setTimeout(()=>{
        tween({ object: d.scale, to: { x:1, y:1, z:1 }, duration: inTime });
        // small approach movement toward patient
        const dest = d.position.clone();
        const approach = dest.clone().lerp(new THREE.Vector3(0, d.position.y, 0.4), 0.45);
        tween({ object: d.position, to: { x: approach.x, y: approach.y, z: approach.z }, duration: inTime + 150 });
        // stay then retreat
        setTimeout(()=>{
          tween({ object: d.position, to: { x: dest.x, y: dest.y, z: dest.z }, duration: outTime });
          tween({ object: d.scale, to: { x:0.001, y:0.001, z:0.001 }, duration: outTime });
        }, inTime + hold);
      }, i * 120);
    });

    // patient reacts slightly
    tween({ object: patientGroup.rotation, to: { x:0.06, y:0, z:0 }, duration: 250, onComplete: ()=>{ tween({ object: patientGroup.rotation, to: { x:0, y:0, z:0 }, duration: 350 }) }});
  }

  // Simple "curative" and "preventive" differ by a little color / blink
  function playCurative(){
    // doctors perform
    playDoctors();
    // small instrument flash near patient (simulated by rim intensification)
    tween({ object: rim, to: { intensity: 1.2 }, duration: 180, onComplete: ()=>{ tween({ object: rim, to: { intensity: 0.3 }, duration: 400 }); }});
  }

  function playPreventive(){
    playDoctors();
    // gentle green aura around patient (temporary)
    const aura = new THREE.PointLight(0x7ee7b7, 0.0, 4);
    aura.position.set(0, 0.3, 0);
    scene.add(aura);
    tween({ object: aura, to: { intensity: 1.2 }, duration: 320, onComplete: ()=>{ tween({ object: aura, to: { intensity: 0.0 }, duration: 700, onComplete: ()=> scene.remove(aura) }); }});
  }

  // Animation loop
  function animate(){
    const dt = clock.getDelta();
    controls.update();
    // small auto-rotation of ring for life
    ring.rotation.z += 0.001 * (1 + Math.sin(clock.elapsedTime * 0.5) * 0.5);
    glow.rotation.z += 0.002;
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  // handle resize
  function onResize(){
    const w = container.clientWidth, h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  }
  window.addEventListener('resize', onResize);

  // UI hookup & "game" logic
  btnCur.addEventListener('click', ()=>{ infoPanel.innerHTML = explanations.curative; playCurative(); markUsed('curative'); });
  btnPrev.addEventListener('click', ()=>{ infoPanel.innerHTML = explanations.preventive; playPreventive(); markUsed('preventive'); });
  btnIRM.addEventListener('click', ()=>{ infoPanel.innerHTML = explanations.irm; playIRM(); markUsed('irm'); });

  function markUsed(key){
    used.add(key);
    if(used.size >= 3){
      setTimeout(()=>{ finish.style.display = 'grid'; }, 1200);
    }
  }

  // start / restart behavior
  startBtn.addEventListener('click', ()=>{
    intro.style.display = 'none';
    appUI.setAttribute('aria-hidden','false');
    // initial camera animation to frame scene
    tween({ object: camera.position, to: { x: 0, y: 4.8, z: 9 }, duration: 900 });
    requestAnimationFrame(animate);
  });

  restartBtn.addEventListener('click', ()=>{
    used.clear();
    finish.style.display = 'none';
    infoPanel.innerHTML = `<p>Testez √† nouveau les 3 m√©thodes.</p>`;
    // reset patient and tube
    patientGroup.position.set(0, -0.4, 0);
    patientGroup.scale.set(1,1,1);
    tubeGroup.scale.set(0.001,0.001,0.001);
    tubeGroup.visible = false;
    doctors.forEach(d => { d.scale.set(0.001,0.001,0.001); });
    // tiny camera bump
    tween({ object: camera.position, to: { x: 0, y: 5, z: 10 }, duration: 700 });
  });

  // initialise small ambient scene before start
  // make tube hidden but place it ready
  tubeGroup.visible = false;

  // keyboard accessibility (Enter = start)
  window.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter' && intro.style.display !== 'none'){ startBtn.click(); }
  });

  // Small safety: ensure renderer is resized to container if it's inserted late
  onResize();
</script>
</body>
</html>
