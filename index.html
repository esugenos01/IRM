<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini-jeu Radiologie ‚Äî Stylis√© & Net (3D)</title>
<style>
  :root{
    --bg:#0b1622; --accent:#6ee7b7; --muted:#9fb3c8; --card:#071428;
    --panel:#071226;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#03121a);color:#e7f3fb}
  .app{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:20px}
  .container{width:100%;max-width:1250px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;display:grid;grid-template-columns:280px 1fr 360px;overflow:hidden;box-shadow:0 12px 40px rgba(0,0,0,.6)}
  .left{padding:20px;border-right:1px solid rgba(255,255,255,0.04);display:flex;flex-direction:column;gap:12px;background:linear-gradient(90deg, rgba(255,255,255,0.01), transparent)}
  .left h2{margin:0;color:var(--accent);font-size:18px}
  .btn{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);padding:12px;border-radius:10px;color:var(--accent);font-weight:700;cursor:pointer;transition:transform .12s, box-shadow .12s}
  .btn:hover{transform:translateY(-4px);box-shadow:0 6px 18px rgba(0,0,0,.45)}
  .center{padding:18px;display:flex;align-items:center;justify-content:center}
  .scene-wrap{width:820px;height:520px;border-radius:10px;overflow:hidden;background:linear-gradient(180deg,#041427,#03202a);display:flex;align-items:center;justify-content:center;box-shadow:inset 0 18px 40px rgba(0,0,0,0.6)}
  canvas{display:block;width:100%;height:100%}
  .right{padding:20px;border-left:1px solid rgba(255,255,255,0.04)}
  .right h3{margin:0;color:var(--accent);font-size:18px}
  .info{margin-top:12px;background:rgba(255,255,255,0.02);padding:14px;border-radius:10px;min-height:160px;color:var(--muted)}
  .overlay{position:fixed;inset:0;display:grid;place-items:center;background:linear-gradient(180deg, rgba(2,6,23,0.75), rgba(2,6,23,0.9));z-index:80}
  .modal{background:linear-gradient(180deg,#071226,#061126);padding:22px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);text-align:center;color:var(--muted);width:88%;max-width:640px}
  .primary{background:linear-gradient(90deg,var(--accent),#9be6d1);border:none;padding:10px 14px;border-radius:10px;color:#052018;font-weight:800;cursor:pointer}
  .small{font-size:13px;color:var(--muted)}
  /* IRM progress indicator (overlay in scene) */
  .irmProgress {
    position:absolute; left:50%; top:6%; transform:translateX(-50%); background:rgba(0,0,0,0.28); padding:6px 10px; border-radius:999px; color:#cfeee6; font-weight:700; font-size:13px; z-index:12;
    backdrop-filter: blur(4px);
  }
  @media (max-width:1100px){
    .container{grid-template-columns:220px 1fr;grid-template-rows:auto auto}
    .right{order:3}
    .scene-wrap{width:92vw;height:52vh}
  }
</style>
</head>
<body>
<div class="app">
  <div class="container" id="uiApp" aria-hidden="true">
    <div class="left">
      <h2>Actions</h2>
      <button class="btn" id="btnCur">1. Appliquer une m√©thode curative</button>
      <button class="btn" id="btnPrev">2. Appliquer une m√©thode pr√©ventive</button>
      <button class="btn" id="btnIRM">3. Faire un IRM</button>
      <div style="flex:1"></div>
      <div class="small">Ce mini-jeu p√©dagogique illustre la radiologie. L'IRM fait r√©ellement entrer le patient dans le tunnel 3D. Les m√©decins apparaissent vus du dessus.</div>
    </div>

    <div class="center">
      <div class="scene-wrap" id="sceneWrap">
        <div class="irmProgress" id="irmProgress" style="display:none">Scan : 0%</div>
        <!-- three.js canvas -->
      </div>
    </div>

    <div class="right">
      <h3>Informations</h3>
      <div class="info" id="info">
        <p>Bienvenue ‚Äî s√©lectionnez une m√©thode √† gauche pour voir l'animation et lire l'explication p√©dagogique.</p>
      </div>
    </div>
  </div>
</div>

<!-- Intro modal -->
<div class="overlay" id="intro">
  <div class="modal">
    <h2 style="color:var(--accent);margin:0">Mini-jeu Radiologie ‚Äî Projet ES</h2>
    <p class="small" style="margin-top:10px">Tu es m√©decin. Observe la sc√®ne et teste : m√©thode curative, m√©thode pr√©ventive, IRM. Appuie sur <strong>Commencer</strong>.</p>
    <div style="margin-top:14px">
      <button class="primary" id="startBtn">Commencer</button>
    </div>
  </div>
</div>

<!-- Finish modal -->
<div class="overlay" id="finish" style="display:none">
  <div class="modal">
    <h2 style="color:var(--accent);margin:0">Patient sauv√© üéâ</h2>
    <p class="small" style="margin-top:10px">F√©licitations ! Tu as test√© les 3 m√©thodes.</p>
    <div style="margin-top:12px">
      <button class="primary" id="restartBtn">Recommencer</button>
    </div>
  </div>
</div>

<!-- Three.js and helpers (modules from CDN) -->
<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
  import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';
  import { EffectComposer } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/UnrealBloomPass.js';
  // module-level small tween helper (no lib)
  function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }
  function tweenProperty(object, propPath, toValue, duration=700, onUpdate=null, onComplete=null){
    // propPath can be 'position.x' or array ['position','x'] etc.
    const start = performance.now();
    const path = Array.isArray(propPath) ? propPath : propPath.split('.');
    let from = object;
    for(let i=0;i<path.length-1;i++) from = from[path[i]];
    const key = path[path.length-1];
    const initial = from[key];
    function frame(now){
      const t = Math.min(1,(now-start)/duration);
      const e = easeOutCubic(t);
      from[key] = initial + (toValue - initial) * e;
      if(onUpdate) onUpdate(e);
      if(t<1) requestAnimationFrame(frame);
      else if(onComplete) onComplete();
    }
    requestAnimationFrame(frame);
  }

  // UI refs
  const startBtn = document.getElementById('startBtn');
  const intro = document.getElementById('intro');
  const uiApp = document.getElementById('uiApp');
  const btnCur = document.getElementById('btnCur');
  const btnPrev = document.getElementById('btnPrev');
  const btnIRM = document.getElementById('btnIRM');
  const info = document.getElementById('info');
  const sceneWrap = document.getElementById('sceneWrap');
  const finish = document.getElementById('finish');
  const restartBtn = document.getElementById('restartBtn');
  const irmProgress = document.getElementById('irmProgress');

  const explanations = {
    curative: `<h4 style="margin:0;color:${getComputedStyle(document.documentElement).getPropertyValue('--accent')}">M√©thode curative</h4>
               <p style="margin:8px 0 0;color:var(--muted)">Intervention guid√©e par image : on traite directement la l√©sion. Exemple : ablation.</p>`,
    preventive: `<h4 style="margin:0;color:${getComputedStyle(document.documentElement).getPropertyValue('--accent')}">M√©thode pr√©ventive</h4>
                 <p style="margin:8px 0 0;color:var(--muted)">Actions pour r√©duire les risques : d√©pistage, surveillance et mesures d'hygi√®ne.</p>`,
    irm: `<h4 style="margin:0;color:${getComputedStyle(document.documentElement).getPropertyValue('--accent')}">IRM</h4>
          <p style="margin:8px 0 0;color:var(--muted)">Imagerie haute d√©finition : ici, le patient p√©n√®tre dans le tunnel pour un scan.</p>`
  };

  // Scene setup
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x041426);

  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(sceneWrap.clientWidth, sceneWrap.clientHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  sceneWrap.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(42, sceneWrap.clientWidth / sceneWrap.clientHeight, 0.1, 200);
  camera.position.set(0, 6.3, 10.8);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.minDistance = 5; controls.maxDistance = 25;
  controls.maxPolarAngle = Math.PI / 2.05;

  // Postprocessing: subtle bloom for crisp highlights
  const composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));
  const bloomPass = new UnrealBloomPass(new THREE.Vector2(sceneWrap.clientWidth, sceneWrap.clientHeight), 0.18, 0.6, 0.9);
  bloomPass.threshold = 0.8; bloomPass.strength = 0.9; bloomPass.radius = 0.2;
  composer.addPass(bloomPass);

  // Lights: crisp three-point-ish lighting
  const hemi = new THREE.HemisphereLight(0xbfeff6, 0x061123, 0.55);
  scene.add(hemi);
  const key = new THREE.DirectionalLight(0xffffff, 0.95);
  key.position.set(6, 9, 5);
  key.castShadow = true;
  key.shadow.mapSize.set(2048,2048);
  key.shadow.camera.left = -10; key.shadow.camera.right = 10; key.shadow.camera.top = 10; key.shadow.camera.bottom = -10;
  scene.add(key);
  const fill = new THREE.DirectionalLight(0xa6dfe0, 0.45);
  fill.position.set(-6, 4, -6);
  scene.add(fill);

  // Ground/table
  const tableMat = new THREE.MeshStandardMaterial({ color: 0x071827, roughness: 0.92, metalness: 0.02 });
  const tableGeo = new THREE.CylinderGeometry(8.5, 8.5, 1.4, 64);
  const table = new THREE.Mesh(tableGeo, tableMat);
  table.receiveShadow = true;
  table.position.y = -1.6;
  scene.add(table);

  // Stylized patient (clean crisp shapes)
  const patient = new THREE.Group();
  patient.position.set(0, -0.2, 0);
  scene.add(patient);
  // head
  const headMat = new THREE.MeshStandardMaterial({ color: 0xffe5cd, roughness: 0.5 });
  const headGeo = new THREE.SphereGeometry(0.6, 40, 26);
  const head = new THREE.Mesh(headGeo, headMat); head.castShadow = true; head.position.set(0, 1.05, 0); patient.add(head);
  // torso capsule
  const torsoMat = new THREE.MeshStandardMaterial({ color: 0xffe2bd, roughness: 0.6 });
  const torso = new THREE.Mesh(new THREE.CapsuleGeometry(0.9, 1.6, 16, 24), torsoMat);
  torso.castShadow = true; torso.position.set(0, -0.3, 0); patient.add(torso);
  // small label plate
  const label = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 0.42), new THREE.MeshBasicMaterial({ color: 0x0b2730 }));
  label.position.set(0, -0.2, 0.98); patient.add(label);

  // Add a thin pillow (slightly reflective)
  const pillow = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.18, 0.9), new THREE.MeshStandardMaterial({ color: 0xcfe9e3, roughness: 0.6 }));
  pillow.position.set(0, 0.4, 0.6); pillow.castShadow = false; patient.add(pillow);

  // MRI tube: composed of ring (front), shell (cylinder), inner fascia for depth
  const tube = new THREE.Group();
  tube.position.set(0, -0.4, 0);
  scene.add(tube);

  const ringMat = new THREE.MeshStandardMaterial({ color: 0xe6fff8, emissive: 0x0c3e36, emissiveIntensity: 0.04, roughness: 0.28 });
  const ring = new THREE.Mesh(new THREE.TorusGeometry(2.2, 0.4, 16, 120), ringMat);
  ring.rotation.x = Math.PI / 2; ring.castShadow = true; tube.add(ring);

  // inner tunnel (smooth cylinder with inside material)
  const tunnelMat = new THREE.MeshStandardMaterial({ color: 0x0b2230, roughness: 0.7, metalness: 0.2, side: THREE.DoubleSide });
  const tunnel = new THREE.Mesh(new THREE.CylinderGeometry(1.05, 1.05, 6.0, 64, 1, true), tunnelMat);
  tunnel.position.set(0, 0, -1.4);
  tube.add(tunnel);

  // inner glowing bands for realism
  const bandMat = new THREE.MeshStandardMaterial({ color: 0x6ee7b7, emissive: 0x6ee7b7, emissiveIntensity: 0.08, roughness: 0.8, transparent:true, opacity:0.18 });
  const band1 = new THREE.Mesh(new THREE.RingGeometry(1.06, 1.9, 64), bandMat); band1.rotation.x = -Math.PI/2; band1.position.set(0,0,-0.5); tube.add(band1);
  const band2 = new THREE.Mesh(new THREE.RingGeometry(1.06, 1.9, 64), bandMat); band2.rotation.x = -Math.PI/2; band2.position.set(0,0,-2.1); tube.add(band2);

  // tube initial state: closed / scaled down
  tube.scale.set(0.0001,0.0001,0.0001); tube.visible = false;

  // Doctors (top-view stylized flat figures) : 4 around patient
  const doctors = [];
  const doctorMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
  const docHeadMat = new THREE.MeshStandardMaterial({ color: 0xffe0c8, roughness: 0.4 });

  const docCoords = [
    new THREE.Vector3(-3.0, -0.4, -0.6),
    new THREE.Vector3(3.0, -0.4, -0.6),
    new THREE.Vector3(-2.0, -0.4, 2.2),
    new THREE.Vector3(2.0, -0.4, 2.2)
  ];

  docCoords.forEach((pos, i)=>{
    const g = new THREE.Group();
    // body plate (flat)
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.18, 1.4), doctorMat);
    body.position.set(0,0,0);
    // head (small sphere)
    const h = new THREE.Mesh(new THREE.SphereGeometry(0.16,16,12), docHeadMat);
    h.position.set(0,0.28,-0.55);

    g.add(body,h);
    g.position.copy(pos);
    g.scale.set(0.0001,0.0001,0.0001);
    scene.add(g);
    doctors.push(g);
  });

  // small helper: make patient "react" (tilt) during operations
  function patientReact(){
    tweenProperty(patient.rotation, 'x', 0.06, 180, null, ()=>{
      tweenProperty(patient.rotation, 'x', 0, 250);
    });
  }

  // show tube with scaling animation
  function showTube(open=true, cb){
    if(open){
      tube.visible = true;
      tube.scale.set(0.0001,0.0001,0.0001);
      tweenProperty(tube.scale,'x',1.0,650);
      tweenProperty(tube.scale,'y',1.0,650);
      tweenProperty(tube.scale,'z',1.0,650, null, ()=>{ if(cb) cb(); });
    } else {
      tweenProperty(tube.scale,'x',0.0001,520);
      tweenProperty(tube.scale,'y',0.0001,520);
      tweenProperty(tube.scale,'z',0.0001,520, null, ()=>{ tube.visible=false; if(cb) cb(); });
    }
  }

  // IRM sequence: open tube, slide patient into tunnel, progress bar, then close tube
  function playIRM(){
    irmProgress.style.display = 'block';
    irmProgress.textContent = 'Scan : 0%';
    showTube(true, ()=>{
      // animate patient forward (z negative)
      tweenProperty(patient.position, 'z', -1.6, 900);
      tweenProperty(patient.scale, 'x', 0.9, 900); tweenProperty(patient.scale, 'y', 0.9, 900); tweenProperty(patient.scale, 'z', 0.9, 900);

      // progress simulation
      let t=0;
      const interval = setInterval(()=>{
        t += Math.random()*8 + 6; // variable increment
        const pct = Math.min(100, Math.round(t));
        irmProgress.textContent = `Scan : ${pct}%`;
        if(pct>=100){
          clearInterval(interval);
          setTimeout(()=>{ // retract patient
            tweenProperty(patient.position,'z',0,700);
            tweenProperty(patient.scale,'x',1.0,700); tweenProperty(patient.scale,'y',1.0,700); tweenProperty(patient.scale,'z',1.0,700);
            // close tube after patient retracted slightly
            setTimeout(()=>{ showTube(false, ()=>{}); irmProgress.style.display='none'; }, 420);
          }, 450);
        }
      }, 80);
    });
  }

  // doctors appear, approach a bit, then leave
  function playDoctors(){
    doctors.forEach((d, i)=>{
      setTimeout(()=>{
        tweenProperty(d.scale, 'x', 1.0, 420); tweenProperty(d.scale, 'y', 1.0, 420); tweenProperty(d.scale, 'z', 1.0, 420);
        const original = d.position.clone();
        const approach = original.clone().lerp(new THREE.Vector3(0, original.y, 0.8), 0.44);
        tweenProperty(d.position, 'x', approach.x, 480); tweenProperty(d.position, 'z', approach.z, 480);
        // hold then retreat
        setTimeout(()=>{
          tweenProperty(d.position, 'x', original.x, 420); tweenProperty(d.position,'z', original.z, 420);
          tweenProperty(d.scale, 'x', 0.0001, 420); tweenProperty(d.scale,'y',0.0001,420); tweenProperty(d.scale,'z',0.0001,420);
        }, 1100 + i*60);
      }, i*90);
    });
  }

  // play curative: doctors + patient react + stronger rim light pulse
  function playCurative(){
    playDoctors();
    patientReact();
    // flash of directional light intensity
    const init = key.intensity;
    tweenProperty(key, 'intensity', init * 1.4, 180, null, ()=>{ tweenProperty(key,'intensity',init,360); });
  }

  // play preventive: doctors + gentle green aura
  function playPreventive(){
    playDoctors();
    patientReact();
    const aura = new THREE.PointLight(0x74f0c8, 0, 3.6);
    aura.position.set(0,0.2,0);
    scene.add(aura);
    tweenProperty(aura, 'intensity', 1.6, 260, null, ()=>{ tweenProperty(aura,'intensity',0,640, null, ()=> scene.remove(aura)); });
  }

  // animation loop
  function resize(){
    const w = sceneWrap.clientWidth, h = sceneWrap.clientHeight;
    camera.aspect = w / h; camera.updateProjectionMatrix();
    renderer.setSize(w,h); composer.setSize(w,h);
  }
  window.addEventListener('resize', resize);

  const clock = new THREE.Clock();
  function renderLoop(){
    controls.update();
    // slight life animations
    ring.rotation.z += 0.002 + Math.sin(clock.getElapsedTime()*0.6)*0.0008;
    band1.rotation.z += 0.0024; band2.rotation.z -= 0.0018;
    composer.render();
    requestAnimationFrame(renderLoop);
  }

  // Game logic: track used methods
  const used = new Set();
  function markUsed(k){
    used.add(k);
    if(used.size>=3){
      setTimeout(()=>{ finish.style.display = 'grid'; }, 900);
    }
  }

  // UI hookups
  btnCur.addEventListener('click', ()=>{ info.innerHTML = explanations.curative; playCurative(); markUsed('cur'); });
  btnPrev.addEventListener('click', ()=>{ info.innerHTML = explanations.preventive; playPreventive(); markUsed('prev'); });
  btnIRM.addEventListener('click', ()=>{ info.innerHTML = explanations.irm; playIRM(); markUsed('irm'); });

  startBtn.addEventListener('click', ()=>{
    intro.style.display='none'; uiApp.setAttribute('aria-hidden','false');
    // initial doctor hidden state
    doctors.forEach(d=> d.scale.set(0.0001,0.0001,0.0001));
    // camera subtle entrance
    tweenProperty(camera.position, 'y', 5.2, 800); tweenProperty(camera.position,'z', 9.8, 900);
    // start rendering
    renderLoop();
  });

  restartBtn.addEventListener('click', ()=>{
    used.clear();
    finish.style.display='none';
    info.innerHTML = '<p>Teste √† nouveau les 3 m√©thodes.</p>';
    // reset patient & tube & doctors
    patient.position.set(0,-0.2,0); patient.scale.set(1,1,1);
    tube.scale.set(0.0001,0.0001,0.0001); tube.visible=false;
    doctors.forEach(d=>{ d.scale.set(0.0001,0.0001,0.0001); });
    irmProgress.style.display='none';
  });

  // kickstart a small ambient frame before start
  resize();
</script>
</body>
</html>
